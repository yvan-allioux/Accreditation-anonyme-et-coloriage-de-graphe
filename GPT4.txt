Ce TP est assez dense et consiste en la mise en place d'un protocole de preuve de connaissance à divulgation nulle pour le problème de coloration de graphes en trois couleurs. Nous allons aborder chaque partie séquentiellement.

1. Génération du graphe et du coloriage
Pour ce faire, nous devons générer un graphe 3-coloriable et le représenter sous forme de matrice d'adjacence.

python
Copy code
import random

class Graphe:
    def __init__(self, nodes=20):
        self.nodes = nodes
        self.adj_matrix = [[0 for _ in range(nodes)] for _ in range(nodes)]
        self.colors = []

    def genererGraphe3Coloriable(self):
        # Étape 1: Assigner une couleur à chaque noeud
        couleurs = ["rouge", "vert", "bleu"]
        self.colors = [random.choice(couleurs) for _ in range(self.nodes)]
        
        # Étape 2: Construire la matrice d'adjacence
        for i in range(self.nodes):
            for j in range(i+1, self.nodes):
                if self.colors[i] != self.colors[j]: # Connecter seulement si les couleurs sont différentes
                    if random.choice([True, False]): # Avec une probabilité de 1/2
                        self.adj_matrix[i][j] = self.adj_matrix[j][i] = 1
                        
        return self
2. Mise en gage des couleurs
Pour cacher les couleurs tout en prouvant leur existence, nous utilisons une fonction de hachage.

python
Copy code
import hashlib

def miseEnGageColoriage(colors, random_values):
    assert len(colors) == len(random_values) == 20
    commitments = []
    for color, random_val in zip(colors, random_values):
        hashed_value = hashlib.sha1((str(random_val) + color).encode()).hexdigest()
        commitments.append(hashed_value)
    return commitments
3. Preuve de connaissance à divulgation nulle d'un 3-coloriage
python
Copy code
def preuveColoriage(matrice, commitments, i, j, colors, random_values):
    # Vérifier les engagements
    if commitments[i] != hashlib.sha1((str(random_values[i]) + colors[i]).encode()).hexdigest():
        return False
    if commitments[j] != hashlib.sha1((str(random_values[j]) + colors[j]).encode()).hexdigest():
        return False

    # Vérifier qu'ils sont connectés
    if matrice[i][j] == 0:
        return False

    # Vérifier que les couleurs sont différentes
    if colors[i] == colors[j]:
        return False
        
    return True
4. Analyse du protocole
Complétude: Si l'utilisateur et le vérificateur sont honnêtes et suivent le protocole, l'utilisateur pourra toujours convaincre le vérificateur car à chaque étape, la vérité est vérifiée (mise en gage, couleurs différentes des noeuds connectés).

Validité: Si un utilisateur ne possède pas une preuve valide, il ne pourra pas produire la mise en gage correcte pour toutes les paires possibles, et donc ne pourra pas convaincre le vérificateur dans tous les essais (400 fois ici).

Divulgation nulle: L'utilisateur ne révèle que deux couleurs à la fois, et ces couleurs sont permutées aléatoirement à chaque fois. Ainsi, le vérificateur ne peut pas déduire la coloration réelle du graphe à partir des informations reçues.

NB: Ceci est une approche basique de l'implémentation. Dans une application réelle, des améliorations et des optimisations supplémentaires seraient nécessaires.